kind: ConfigMap
apiVersion: v1
metadata:
  name: clusterplex-pms-config
  labels:
    app.kubernetes.io/name: clusterplex-pms-config
    app.kubernetes.io/part-of: clusterplex
data:
  VERSION: docker
  TZ: ${TIMEZONE}
  PGID: '1000'
  PUID: '1000'
  DOCKER_MODS: 'ghcr.io/pabloromeo/clusterplex_dockermod:latest'
  ORCHESTRATOR_URL: 'http://clusterplex-orchestrator:3500'
  PMS_SERVICE: "clusterplex-pms"
  PMS_PORT: "32400"
  TRANSCODER_VERBOSE: '1'
  TRANSCODE_OPERATING_MODE: remote
  LOCAL_RELAY_ENABLED: '1'
  LOCAL_RELAY_PORT: "32499"
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: clusterplex-orchestrator-config
  labels:
    app.kubernetes.io/name: clusterplex-orchestrator-config
    app.kubernetes.io/part-of: clusterplex
data:
  TZ: ${TIMEZONE}
  LISTENING_PORT: '3500'
  WORKER_SELECTION_STRATEGY: LOAD_TASKS
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: clusterplex-worker-config
  labels:
    app.kubernetes.io/name: clusterplex-worker-config
    app.kubernetes.io/part-of: clusterplex
data:
  TZ: ${TIMEZONE}
  PGID: '1000'
  PUID: '1000'
  VERSION: docker
  DOCKER_MODS: 'ghcr.io/pabloromeo/clusterplex_worker_dockermod:1.4.16'
  ORCHESTRATOR_URL: 'http://clusterplex-orchestrator:3500'
  LISTENING_PORT: '3501'
  STAT_CPU_INTERVAL: '10000'
  EAE_SUPPORT: '1'
  FFMPEG_HWACCEL: 'vaapi'
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: clusterplex-worker-init-script
  labels:
    app.kubernetes.io/name: clusterplex-worker-init-script
    app.kubernetes.io/part-of: clusterplex
data:
  setup-gpu-drivers.sh: |
    #!/bin/bash

    # Log to a file to verify script is running
    LOG_FILE="/config/gpu-driver-setup.log"
    echo "[PostStart] GPU driver setup started at $(date)" | tee -a "$LOG_FILE"

    echo "[PostStart] Setting up GPU drivers for hardware transcoding..." | tee -a "$LOG_FILE"

    # Create the cache directory structure
    CACHE_DIR="/config/Library/Application Support/Plex Media Server/Cache/va-dri-linux-x86_64"
    mkdir -p "$CACHE_DIR"

    # Check if symlinks already exist and are valid
    if [ -L "$CACHE_DIR/iHD_drv_video.so" ] || [ -L "$CACHE_DIR/i965_drv_video.so" ]; then
        echo "[PostStart] Driver symlinks already exist" | tee -a "$LOG_FILE"
        ls -la "$CACHE_DIR" | tee -a "$LOG_FILE"
        exit 0
    fi

    # Remove any existing files (from previous failed attempts)
    echo "[PostStart] Cleaning up old driver files..." | tee -a "$LOG_FILE"
    rm -f "$CACHE_DIR"/*.so 2>/dev/null || true

    echo "[PostStart] Checking if drivers are already installed..." | tee -a "$LOG_FILE"

    # First check if drivers are already installed in the system
    FOUND_DRIVERS=false
    for location in "/usr/lib/x86_64-linux-gnu/dri" "/usr/lib/dri" "/usr/local/lib/dri" "/usr/lib/plexmediaserver/lib/dri"; do
        if [ -d "$location" ]; then
            echo "[PostStart] Checking $location..." | tee -a "$LOG_FILE"
            if [ -f "$location/iHD_drv_video.so" ] || [ -f "$location/i965_drv_video.so" ]; then
                FOUND_DRIVERS=true
                break
            fi
        fi
    done

    # Only install if not found
    if [ "$FOUND_DRIVERS" = false ]; then
        echo "[PostStart] Installing Intel GPU drivers..." | tee -a "$LOG_FILE"
        apt-get update 2>&1 | tail -5 | tee -a "$LOG_FILE"
        DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            intel-media-va-driver-non-free \
            i965-va-driver 2>&1 | tail -10 | tee -a "$LOG_FILE"
    fi

    echo "[PostStart] Creating symlinks to installed drivers..." | tee -a "$LOG_FILE"

    # Create symlinks instead of copying to avoid library mismatch
    # Check multiple possible locations
    DRIVER_LOCATIONS=(
        "/usr/lib/x86_64-linux-gnu/dri"
        "/usr/lib/dri"
        "/usr/local/lib/dri"
    )

    for location in "/usr/lib/x86_64-linux-gnu/dri" "/usr/lib/dri" "/usr/local/lib/dri"; do
        if [ -d "$location" ]; then
            echo "[PostStart] Checking $location for drivers..."

            # iHD driver for newer Intel GPUs
            if [ -f "$location/iHD_drv_video.so" ]; then
                ln -sf "$location/iHD_drv_video.so" "$CACHE_DIR/iHD_drv_video.so"
                echo "[PostStart] Created symlink: $CACHE_DIR/iHD_drv_video.so -> $location/iHD_drv_video.so" | tee -a "$LOG_FILE"
            fi

            # i965 driver for older Intel GPUs
            if [ -f "$location/i965_drv_video.so" ]; then
                ln -sf "$location/i965_drv_video.so" "$CACHE_DIR/i965_drv_video.so"
                echo "[PostStart] Created symlink: $CACHE_DIR/i965_drv_video.so -> $location/i965_drv_video.so" | tee -a "$LOG_FILE"
            fi
        fi
    done

    # Set proper permissions
    chown -R abc:abc "/config/Library" 2>/dev/null || true
    chmod -R 755 "$CACHE_DIR" 2>/dev/null || true

    echo "[PostStart] GPU driver cache contents:" | tee -a "$LOG_FILE"
    ls -la "$CACHE_DIR" | tee -a "$LOG_FILE"

    # Verify symlinks are valid
    if [ -L "$CACHE_DIR/iHD_drv_video.so" ] && [ -e "$CACHE_DIR/iHD_drv_video.so" ]; then
        echo "[PostStart] SUCCESS: iHD driver symlink is valid" | tee -a "$LOG_FILE"
    fi

    if [ -L "$CACHE_DIR/i965_drv_video.so" ] && [ -e "$CACHE_DIR/i965_drv_video.so" ]; then
        echo "[PostStart] SUCCESS: i965 driver symlink is valid" | tee -a "$LOG_FILE"
    fi

    # Final check
    if [ ! -L "$CACHE_DIR/iHD_drv_video.so" ] && [ ! -L "$CACHE_DIR/i965_drv_video.so" ]; then
        echo "[PostStart] ERROR: No Intel GPU drivers available!" | tee -a "$LOG_FILE"
        echo "[PostStart] Hardware transcoding will not work." | tee -a "$LOG_FILE"
    else
        echo "[PostStart] GPU driver setup complete - hardware transcoding should work" | tee -a "$LOG_FILE"
    fi

    echo "[PostStart] Setup completed at $(date)" | tee -a "$LOG_FILE"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: clusterplex-config
  labels:
    app.kubernetes.io/name: clusterplex-config
    app.kubernetes.io/part-of: clusterplex
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: "10Gi"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: clusterplex-transcode
  labels:
    app.kubernetes.io/name: clusterplex-transcode
    app.kubernetes.io/part-of: clusterplex
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: "10Gi"
  storageClassName: rook-cephfs
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: clusterplex-pms
  labels:
    app.kubernetes.io/name: clusterplex-pms
    app.kubernetes.io/part-of: clusterplex
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: clusterplex-pms
      app.kubernetes.io/part-of: clusterplex
  template:
    metadata:
      labels:
        app.kubernetes.io/name: clusterplex-pms
        app.kubernetes.io/part-of: clusterplex
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: clusterplex-worker
              topologyKey: kubernetes.io/hostname
            weight: 50
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: clusterplex-pms
              topologyKey: kubernetes.io/hostname
            weight: 100
      containers:
      - name: plex
        image: lscr.io/linuxserver/plex:latest
        startupProbe:
          httpGet:
            path: /identity
            scheme: HTTPS
            port: 32400
          failureThreshold: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /identity
            scheme: HTTPS
            port: 32400
          initialDelaySeconds: 15
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /identity
            scheme: HTTPS
            port: 32400
          initialDelaySeconds: 10
          timeoutSeconds: 10
        ports:
          - name: pms
            containerPort: 32400
          - name: relay
            containerPort: 32499
        envFrom:
        - configMapRef:
            name: clusterplex-pms-config
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /config
        - name: transcode
          mountPath: /transcode
        # resources:          # adapt requests and limits to your needs
        #   requests:
        #     cpu: 300m
        #     memory: 256Mi
        #   limits:
        #     cpu: 2000m
        #     memory: 512Mi
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: "media-share"
      - name: config
        persistentVolumeClaim:
          claimName: "clusterplex-config"
      - name: transcode
        persistentVolumeClaim:
          claimName: "clusterplex-transcode"
---
apiVersion: v1
kind: Service
metadata:
  name: clusterplex-pms
  labels:
    app.kubernetes.io/name: clusterplex-pms
    app.kubernetes.io/part-of: clusterplex
spec:
  type: ClusterIP
  ports:
    - name: pms
      port: 32400
      protocol: TCP
      targetPort: pms
    - name: relay
      port: 32499
      protocol: TCP
      targetPort: relay
  selector:
    app.kubernetes.io/name: clusterplex-pms
    app.kubernetes.io/part-of: clusterplex
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: clusterplex-orchestrator
  labels:
    app.kubernetes.io/name: clusterplex-orchestrator
    app.kubernetes.io/part-of: clusterplex
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: clusterplex-orchestrator
      app.kubernetes.io/part-of: clusterplex
  template:
    metadata:
      labels:
        app.kubernetes.io/name: clusterplex-orchestrator
        app.kubernetes.io/part-of: clusterplex
    spec:
      containers:
      - name: plex
        image: ghcr.io/pabloromeo/clusterplex_orchestrator:latest
        startupProbe:
          httpGet:
            path: /health
            port: 3500
          failureThreshold: 3
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3500
          initialDelaySeconds: 5
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /health
            port: 3500
          initialDelaySeconds: 5
          timeoutSeconds: 10
        ports:
          - name: orchestrator
            containerPort: 3500
        envFrom:
        - configMapRef:
            name: clusterplex-orchestrator-config
        resources:            # adapt requests and limits to your needs
          requests:
            cpu: 200m
            memory: 32Mi
          limits:
            cpu: 500m
            memory: 64Mi
---
apiVersion: v1
kind: Service
metadata:
  name: clusterplex-orchestrator
  labels:
    app.kubernetes.io/name: clusterplex-orchestrator
    app.kubernetes.io/part-of: clusterplex
spec:
  type: ClusterIP
  ports:
    - name: orchestrator
      port: 3500
      protocol: TCP
      targetPort: orchestrator
  selector:
    app.kubernetes.io/name: clusterplex-orchestrator
    app.kubernetes.io/part-of: clusterplex
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: clusterplex-worker
  labels:
    app.kubernetes.io/name: clusterplex-worker
    app.kubernetes.io/part-of: clusterplex
spec:
  serviceName: clusterplex-worker-service
  podManagementPolicy: Parallel
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: clusterplex-worker
      app.kubernetes.io/part-of: clusterplex
  template:
    metadata:
      labels:
        app.kubernetes.io/name: clusterplex-worker
        app.kubernetes.io/part-of: clusterplex
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: clusterplex-worker
              topologyKey: kubernetes.io/hostname
            weight: 100
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: clusterplex-pms
              topologyKey: kubernetes.io/hostname
            weight: 50
      containers:
      - name: plex-worker
        image: lscr.io/linuxserver/plex:latest
        securityContext:
          privileged: true
        lifecycle:
          postStart:
            exec:
              command: ["/bin/bash", "/scripts/setup-gpu-drivers.sh"]
        startupProbe:
          httpGet:
            path: /health
            port: 3501
          failureThreshold: 40
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3501
          initialDelaySeconds: 60
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /health
            port: 3501
          initialDelaySeconds: 10
          timeoutSeconds: 10
        ports:
          - name: worker
            containerPort: 3501
        envFrom:
        - configMapRef:
            name: clusterplex-worker-config
        volumeMounts:
        - name: data
          mountPath: /data
        - name: worker-config
          mountPath: /config
        - name: codecs
          mountPath: /codecs
        - name: transcode
          mountPath: /transcode
        - name: init-scripts
          mountPath: /scripts
        resources:
          requests:
            gpu.intel.com/i915: "10"
          limits:
            gpu.intel.com/i915: "10"
        # resources:              # adapt requests and limits to your needs
        #   requests:
        #     cpu: 500m
        #     memory: 200Mi
        #   limits:
        #     cpu: 3000m
        #     memory: 800Mi
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: "media-share"
      - name: transcode
        persistentVolumeClaim:
          claimName: "clusterplex-transcode"
      - name: worker-config
        emptyDir: {}
      - name: init-scripts
        configMap:
          name: clusterplex-worker-init-script
          defaultMode: 0755
  volumeClaimTemplates:
    - metadata:
        name: codecs
        labels:
          app.kubernetes.io/name: clusterplex-codecs
          app.kubernetes.io/part-of: clusterplex
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 1Gi
        # specify your storage class
        #storageClassName: longhorn
---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: clusterplex
  namespace: media
  annotations:
    item.homer.rajsingh.info/name: "ClusterPlex"
    item.homer.rajsingh.info/subtitle: "Media Server"
    item.homer.rajsingh.info/logo: "https://raw.githubusercontent.com/walkxcode/dashboard-icons/main/svg/plex.svg"
    item.homer.rajsingh.info/keywords: "media, server, streaming"
    service.homer.rajsingh.info/name: "Media"
    service.homer.rajsingh.info/icon: "fas fa-tv"
spec:
  parentRefs:
    - group: gateway.networking.k8s.io
      kind: Gateway
      name: private
      namespace: home
    - group: gateway.networking.k8s.io
      kind: Gateway
      name: ts
      namespace: home
    - group: gateway.networking.k8s.io
      kind: Gateway
      name: public
      namespace: home
  hostnames:
    - "clusterplex.${CLUSTER_DOMAIN}"
  rules:
    - backendRefs:
        - group: ""
          kind: Service
          name: clusterplex-pms
          port: 32400
          weight: 1
      filters:
        - type: RequestHeaderModifier
          requestHeaderModifier:
            set:
              - name: "X-Forwarded-Proto"
                value: "https"
        - type: ResponseHeaderModifier
          responseHeaderModifier:
            remove:
              - "Server"
              - "X-XSS-Protection"
            set:
              - name: "X-Content-Type-Options"
                value: "nosniff"
              - name: "X-Frame-Options"
                value: "SAMEORIGIN"
              - name: "Cache-Control"
                value: "no-transform"
      matches:
        - path:
            type: PathPrefix
            value: /